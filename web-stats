#!/usr/bin/env python3
import datetime
import json
import pickle
import sys
import typing as T
from dataclasses import dataclass
from pathlib import Path

import dedibox
import neocities
import nyaa_si

import configargparse
import jinja2
import markdown
import xdg

CACHE_PATH = Path(xdg.XDG_CACHE_HOME) / 'oc-web-stats.dat'
ROOT_PATH = Path(__file__).parent


def json_default(obj: T.Any) -> T.Any:
    if isinstance(obj, (datetime.datetime, datetime.date)):
        return obj.isoformat()
    return obj.__dict__


@dataclass
class Torrent:
    source: str
    torrent_id: int
    torrent_link: str
    name: str
    size: int
    upload_date: datetime.datetime
    seeder_count: int
    leecher_count: int
    download_count: int
    comment_count: int
    visible: bool


@dataclass
class Comment:
    source: str
    comment_date: datetime.datetime
    author_name: str
    author_avatar_url: T.Optional[str]
    text: str
    torrent: T.Optional[Torrent]


@dataclass
class Context:
    neocities_stats: T.List[neocities.TrafficStat]
    dedibox_torrent_stats: dedibox.TorrentStats
    guestbook_comments: T.List[dedibox.GuestbookComment]
    nyaa_si_torrents: T.List[nyaa_si.Torrent]
    nyaa_si_comments: T.List[nyaa_si.TorrentComment]


def parse_args() -> configargparse.Namespace:
    parser = configargparse.ArgumentParser(
        formatter_class=configargparse.RawTextHelpFormatter,
        default_config_files=[Path(xdg.XDG_CONFIG_HOME) / 'oc-tools.yml']
    )

    parser.add_argument('--neocities-user', required=True)
    parser.add_argument('--neocities-pass', required=True)
    parser.add_argument('--dedibox-user', required=True)
    parser.add_argument('--dedibox-pass', required=True)
    parser.add_argument('--nyaasi-user', required=True)
    parser.add_argument('--nyaasi-pass', required=True)
    parser.add_argument('-d', '--dev', action='store_true')
    parser.add_argument(
        '-o',
        '--output',
        default=Path('stats.html'),
        type=Path,
        required=False
    )

    return parser.parse_known_args()[0]


class ContextBuilder:
    def __init__(
            self,
            args: configargparse.Namespace,
            cached_context: T.Optional[Context]
    ) -> None:
        self.args = args
        self.cached_context = cached_context

    def build(self) -> Context:
        neocities_stats = self.build_neocities_output()
        guestbook_comments, dedibox_torrent_stats = self.build_dedibox_output()
        nyaa_si_torrents, nyaa_si_comments = self.build_nyaa_si_output()

        return Context(
            neocities_stats=neocities_stats,
            dedibox_torrent_stats=dedibox_torrent_stats,
            guestbook_comments=guestbook_comments,
            nyaa_si_torrents=nyaa_si_torrents,
            nyaa_si_comments=nyaa_si_comments,
        )

    def build_dedibox_output(self) -> T.Tuple[
            T.List[dedibox.GuestbookComment],
            dedibox.TorrentStats
    ]:
        api = dedibox.DediboxApi()
        print('Logging into dedibox…', file=sys.stderr)
        api.login(self.args.dedibox_user, self.args.dedibox_pass)
        print('Getting guest book comment list…', file=sys.stderr)
        guestbook_comments = list(api.list_guestbook_comments())
        print('Getting transmission stats…', file=sys.stderr)
        torrent_stats = api.get_torrent_stats()
        return guestbook_comments, torrent_stats

    def build_neocities_output(self) -> T.List[neocities.TrafficStat]:
        api = neocities.NeocitiesApi()
        print('Logging into neocities…', file=sys.stderr)
        api.login(self.args.neocities_user, self.args.neocities_pass)
        print('Grabbing website traffic stats…', file=sys.stderr)
        return list(api.get_traffic_stats())

    def build_nyaa_si_output(self) -> T.Tuple[
            T.List[nyaa_si.Torrent],
            T.List[nyaa_si.TorrentComment]
    ]:
        api = nyaa_si.NyaaSiApi()
        print(f'Logging into nyaa.si…', file=sys.stderr)
        api.login(self.args.nyaasi_user, self.args.nyaasi_pass)

        print(f'Getting nyaa.si torrent list…', file=sys.stderr)
        torrents = list(api.list_user_torrents(self.args.nyaasi_user))
        comments: T.List[nyaa_si.TorrentComment] = []

        for torrent in torrents:
            if self.cached_context:
                cached_comments = [
                    comment
                    for comment in self.cached_context.nyaa_si_comments
                    if comment.torrent_id == torrent.torrent_id
                ]
            else:
                cached_comments = []

            if len(cached_comments) == torrent.comment_count:
                comments += cached_comments
            else:
                print(
                    f'Getting nyaa.si comments for "{torrent.name}"…',
                    file=sys.stderr
                )
                comments += list(api.list_torrent_comments(torrent.torrent_id))

        return torrents, comments


def write_report(args: configargparse.Namespace, context: Context) -> None:
    torrents = []
    for torrent in context.nyaa_si_torrents:
        torrents.append(Torrent(
            source='nyaa.si',
            torrent_id=torrent.torrent_id,
            torrent_link=f'https://nyaa.si/view/{torrent.torrent_id}',
            name=torrent.name,
            size=torrent.size,
            upload_date=torrent.upload_date,
            seeder_count=torrent.seeder_count,
            leecher_count=torrent.leecher_count,
            download_count=torrent.download_count,
            comment_count=torrent.comment_count,
            visible=torrent.visible
        ))

    comments = []
    for comment in context.nyaa_si_comments:
        comments.append(Comment(
            source='nyaa.si',
            comment_date=comment.comment_date,
            author_name=comment.author_name,
            author_avatar_url=comment.author_avatar_url,
            text=comment.text,
            torrent=next(
                torrent
                for torrent in torrents
                if torrent.torrent_id == comment.torrent_id
            )
        ))

    for comment in context.guestbook_comments:
        comments.append(Comment(
            source='guestbook',
            comment_date=comment.comment_date,
            author_name=comment.author_name,
            author_avatar_url=None,
            text=comment.text,
            torrent=None
        ))

    print(f'Writing output to {args.output}…', file=sys.stderr)
    md = markdown.Markdown(extensions=['meta'])
    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(str(ROOT_PATH / 'data'))
    )
    env.filters['markdown'] = lambda text: jinja2.Markup(md.convert(text))
    env.filters['tojson'] = lambda obj: json.dumps(obj, default=json_default)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(
        env
        .get_template('report.html')
        .render(
            date=datetime.datetime.now(),
            neocities_stats=context.neocities_stats,
            dedibox_torrent_stats=context.dedibox_torrent_stats,
            torrents=torrents,
            comments=comments,
        )
    )


def main() -> None:
    args = parse_args()

    if CACHE_PATH.exists():
        prev_context = pickle.loads(CACHE_PATH.read_bytes())
    else:
        prev_context = None

    if args.dev and prev_context:
        context = prev_context
    else:
        context = ContextBuilder(args, prev_context).build()

    CACHE_PATH.write_bytes(pickle.dumps(context))

    write_report(args, context)


if __name__ == '__main__':
    main()
