#!/usr/bin/env python3
import datetime
import json
import pickle
import sys
import typing as T
from dataclasses import dataclass
from pathlib import Path

import configargparse
import jinja2
import markdown
import xdg

import anidex
import dedibox
import neocities
import nyaa_si

CACHE_PATH = Path(xdg.XDG_CACHE_HOME) / "oc-web-stats.dat"
ROOT_PATH = Path(__file__).parent


def json_default(obj: T.Any) -> T.Any:
    if isinstance(obj, (datetime.datetime, datetime.date)):
        return obj.isoformat()
    return obj.__dict__


@dataclass
class Context:
    neocities_stats: T.List[neocities.TrafficStat]
    dedibox_torrent_stats: dedibox.TorrentStats
    guestbook_comments: T.List[dedibox.GuestbookComment]
    anidex_torrents: T.List[anidex.Torrent]
    nyaa_si_torrents: T.List[nyaa_si.Torrent]
    nyaa_si_comments: T.List[nyaa_si.TorrentComment]


class ContextBuilder:
    def __init__(
        self,
        args: configargparse.Namespace,
        cached_context: T.Optional[Context],
    ) -> None:
        self.args = args
        self.cached_context = cached_context

    def build(self) -> Context:
        guestbook_comments, dedibox_torrent_stats = self.build_dedibox_output()
        neocities_stats = self.build_neocities_output()
        nyaa_si_torrents, nyaa_si_comments = self.build_nyaa_si_output()
        anidex_torrents = self.build_anidex_output()

        return Context(
            neocities_stats=neocities_stats,
            dedibox_torrent_stats=dedibox_torrent_stats,
            guestbook_comments=guestbook_comments,
            nyaa_si_torrents=nyaa_si_torrents,
            nyaa_si_comments=nyaa_si_comments,
            anidex_torrents=anidex_torrents,
        )

    def build_dedibox_output(
        self
    ) -> T.Tuple[T.List[dedibox.GuestbookComment], dedibox.TorrentStats]:
        api = dedibox.Api()
        print("Logging into dedibox…", file=sys.stderr)
        api.login(self.args.dedibox_user, self.args.dedibox_pass)
        print("Getting guest book comment list…", file=sys.stderr)
        guestbook_comments = list(api.list_guestbook_comments())
        print("Getting transmission stats…", file=sys.stderr)
        torrent_stats = api.get_torrent_stats()
        return guestbook_comments, torrent_stats

    def build_neocities_output(self) -> T.List[neocities.TrafficStat]:
        api = neocities.Api()
        print("Logging into neocities…", file=sys.stderr)
        api.login(self.args.neocities_user, self.args.neocities_pass)
        print("Grabbing website traffic stats…", file=sys.stderr)
        return list(api.get_traffic_stats())

    def build_nyaa_si_output(
        self
    ) -> T.Tuple[T.List[nyaa_si.Torrent], T.List[nyaa_si.TorrentComment]]:
        api = nyaa_si.Api()
        print(f"Logging into nyaa.si…", file=sys.stderr)
        api.login(self.args.nyaasi_user, self.args.nyaasi_pass)

        print(f"Getting nyaa.si torrent list…", file=sys.stderr)
        torrents = list(api.list_user_torrents(self.args.nyaasi_user))
        comments: T.List[nyaa_si.TorrentComment] = []

        for torrent in torrents:
            if self.cached_context:
                cached_comments = [
                    comment
                    for comment in self.cached_context.nyaa_si_comments
                    if comment.torrent_id == torrent.torrent_id
                ]
            else:
                cached_comments = []

            if len(cached_comments) == torrent.comment_count:
                comments += cached_comments
            else:
                print(
                    f'Getting nyaa.si comments for "{torrent.name}"…',
                    file=sys.stderr,
                )
                comments += list(api.list_torrent_comments(torrent.torrent_id))

        return torrents, comments

    def build_anidex_output(self) -> T.List[anidex.Torrent]:
        try:
            api = anidex.Api()
            print(f"Logging into anidex.info…", file=sys.stderr)
            api.login(self.args.anidex_user, self.args.anidex_pass)

            def page_callback(offset: int) -> None:
                print(
                    f"Getting anidex.info torrent list… (offset {offset})",
                    file=sys.stderr,
                )

            print(f"Getting anidex.info torrent list…", file=sys.stderr)
            return list(
                api.list_group_torrents(self.args.anidex_group, page_callback)
            )
        except anidex.api.ApiError as ex:
            print(ex)
            return []


@dataclass
class Torrent:
    source: str
    torrent_id: int
    torrent_link: str
    name: str
    size: int
    upload_date: datetime.datetime
    seeder_count: int
    leecher_count: int
    download_count: int
    comment_count: int
    visible: bool


@dataclass
class Comment:
    source: str
    comment_date: datetime.datetime
    author_name: str
    author_avatar_url: T.Optional[str]
    text: str
    torrent: T.Optional[Torrent]


@dataclass
class TrafficStat:
    day: datetime.date
    hits: int
    views: int
    hits_avg: float
    views_avg: float


class ReportContext:
    def __init__(self, context: Context) -> None:
        self.date = datetime.datetime.now()
        self.dedibox_torrent_stats = context.dedibox_torrent_stats

        self.traffic_stats: T.List[TrafficStat] = []
        try:
            import scipy.signal

            weights = {
                key - 21: value
                for key, value in enumerate(
                    scipy.signal.gaussian(M=21 * 2 + 1, std=7)
                )
            }
        except ImportError:
            weights = {
                -21: 0.011_108,
                -20: 0.016_879,
                -19: 0.025_130,
                -18: 0.036_658,
                -17: 0.052_393,
                -16: 0.073_369,
                -15: 0.100_668,
                -14: 0.135_335,
                -13: 0.178_263,
                -12: 0.230_066,
                -11: 0.290_923,
                -10: 0.360_447,
                -9: 0.437_564,
                -8: 0.520_450,
                -7: 0.606_530,
                -6: 0.692_569,
                -5: 0.774_837,
                -4: 0.849_365,
                -3: 0.912_254,
                -2: 0.960_005,
                -1: 0.989_847,
                0: 1.0,
                1: 0.989_847,
                2: 0.960_005,
                3: 0.912_254,
                4: 0.849_365,
                5: 0.774_837,
                6: 0.692_569,
                7: 0.606_530,
                8: 0.520_450,
                9: 0.437_564,
                10: 0.360_447,
                11: 0.290_923,
                12: 0.230_066,
                13: 0.178_263,
                14: 0.135_335,
                15: 0.100_668,
                16: 0.073_369,
                17: 0.052_393,
                18: 0.036_658,
                19: 0.025_130,
                20: 0.016_879,
                21: 0.011_108,
            }

        for i, item in enumerate(context.neocities_stats):
            total_weight = 0
            hits_avg = 0
            views_avg = 0
            for delta, weight in weights.items():
                try:
                    other_item = context.neocities_stats[i + delta]
                except LookupError:
                    continue
                hits_avg += other_item.hits * weight
                views_avg += other_item.views * weight
                total_weight += weight

            self.traffic_stats.append(
                TrafficStat(
                    day=item.day,
                    hits=item.hits,
                    views=item.views,
                    hits_avg=hits_avg / max(1, total_weight),
                    views_avg=views_avg / max(1, total_weight),
                )
            )

        self.torrents: T.List[Torrent] = []
        for nyaa_si_torrent in context.nyaa_si_torrents:
            self.torrents.append(self._torrent_from_nyaa_si(nyaa_si_torrent))

        for anidex_torrent in context.anidex_torrents:
            self.torrents.append(self._torrent_from_anidex(anidex_torrent))

        self.comments: T.List[Comment] = []
        for nyaa_si_comment in context.nyaa_si_comments:
            self.comments.append(
                self._comment_from_nyaa_si(nyaa_si_comment, self.torrents)
            )

        for guestbook_comment in context.guestbook_comments:
            self.comments.append(
                self._comment_from_guestbook(guestbook_comment)
            )

    @staticmethod
    def _torrent_from_nyaa_si(torrent: nyaa_si.Torrent) -> Torrent:
        return Torrent(
            source="nyaa.si",
            torrent_id=torrent.torrent_id,
            torrent_link=f"https://nyaa.si/view/{torrent.torrent_id}",
            name=torrent.name,
            size=torrent.size,
            upload_date=torrent.upload_date,
            seeder_count=torrent.seeder_count,
            leecher_count=torrent.leecher_count,
            download_count=torrent.download_count,
            comment_count=torrent.comment_count,
            visible=torrent.visible,
        )

    @staticmethod
    def _torrent_from_anidex(torrent: anidex.Torrent) -> Torrent:
        return Torrent(
            source="anidex.info",
            torrent_id=torrent.torrent_id,
            torrent_link=f"https://anidex.info/torrent/{torrent.torrent_id}",
            name=torrent.name,
            size=torrent.size,
            upload_date=torrent.upload_date,
            seeder_count=torrent.seeder_count,
            leecher_count=torrent.leecher_count,
            download_count=torrent.download_count,
            comment_count=torrent.comment_count,
            visible=torrent.visible,
        )

    @staticmethod
    def _comment_from_nyaa_si(
        comment: nyaa_si.TorrentComment, torrents: T.List[Torrent]
    ) -> Comment:
        return Comment(
            source="nyaa.si",
            comment_date=comment.comment_date,
            author_name=comment.author_name,
            author_avatar_url=comment.author_avatar_url,
            text=comment.text,
            torrent=next(
                torrent
                for torrent in torrents
                if torrent.torrent_id == comment.torrent_id
                and torrent.source == "nyaa.si"
            ),
        )

    @staticmethod
    def _comment_from_guestbook(comment: dedibox.GuestbookComment) -> Comment:
        return Comment(
            source="guestbook",
            comment_date=comment.comment_date,
            author_name=comment.author_name,
            author_avatar_url=comment.author_avatar_url,
            text=comment.text,
            torrent=None,
        )


def percent(
    dividend: T.Union[int, float], divisor: T.Union[int, float]
) -> str:
    if not divisor:
        return "0.0"
    return f"{dividend / divisor:.2f}"


def write_report(
    args: configargparse.Namespace, report_context: ReportContext
) -> None:
    print(f"Writing output to {args.output}…", file=sys.stderr)
    md = markdown.Markdown(extensions=["meta"])
    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(str(ROOT_PATH / "data"))
    )
    env.filters["markdown"] = lambda text: jinja2.Markup(md.convert(text))
    env.filters["tojson"] = lambda obj: json.dumps(obj, default=json_default)
    env.globals.update(percent=percent)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(
        env.get_template("report.html").render(**report_context.__dict__)
    )


def parse_args() -> configargparse.Namespace:
    parser = configargparse.ArgumentParser(
        formatter_class=configargparse.RawTextHelpFormatter,
        default_config_files=[str(Path(xdg.XDG_CONFIG_HOME) / "oc-tools.yml")],
    )

    parser.add_argument("--neocities-user", required=True)
    parser.add_argument("--neocities-pass", required=True)
    parser.add_argument("--dedibox-user", required=True)
    parser.add_argument("--dedibox-pass", required=True)
    parser.add_argument("--anidex-user", required=True)
    parser.add_argument("--anidex-pass", required=True)
    parser.add_argument("--anidex-group", type=int, required=True)
    parser.add_argument("--nyaasi-user", required=True)
    parser.add_argument("--nyaasi-pass", required=True)
    parser.add_argument("-d", "--dev", action="store_true")
    parser.add_argument(
        "-o", "--output", default=Path("stats.html"), type=Path, required=False
    )

    return parser.parse_known_args()[0]


def main() -> None:
    args = parse_args()

    if CACHE_PATH.exists():
        prev_context = pickle.loads(CACHE_PATH.read_bytes())
    else:
        prev_context = None

    if args.dev and prev_context:
        context = prev_context
    else:
        context = ContextBuilder(args, prev_context).build()

    CACHE_PATH.write_bytes(pickle.dumps(context))

    report_context = ReportContext(context)
    write_report(args, report_context)


if __name__ == "__main__":
    main()
