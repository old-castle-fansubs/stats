#!/usr/bin/env python3
import datetime
import json
import pickle
import sys
import typing as T
from dataclasses import dataclass
from pathlib import Path

import configargparse
import jinja2
import markdown
import xdg

import anidex
import dedibox
import neocities
import nyaa_si

CACHE_PATH = Path(xdg.XDG_CACHE_HOME) / 'oc-web-stats.dat'
ROOT_PATH = Path(__file__).parent


def json_default(obj: T.Any) -> T.Any:
    if isinstance(obj, (datetime.datetime, datetime.date)):
        return obj.isoformat()
    return obj.__dict__


@dataclass
class Context:
    neocities_stats: T.List[neocities.TrafficStat]
    dedibox_torrent_stats: dedibox.TorrentStats
    guestbook_comments: T.List[dedibox.GuestbookComment]
    anidex_torrents: T.List[anidex.Torrent]
    nyaa_si_torrents: T.List[nyaa_si.Torrent]
    nyaa_si_comments: T.List[nyaa_si.TorrentComment]


class ContextBuilder:
    def __init__(
            self,
            args: configargparse.Namespace,
            cached_context: T.Optional[Context]
    ) -> None:
        self.args = args
        self.cached_context = cached_context

    def build(self) -> Context:
        anidex_torrents = self.build_anidex_output()
        neocities_stats = self.build_neocities_output()
        guestbook_comments, dedibox_torrent_stats = self.build_dedibox_output()
        nyaa_si_torrents, nyaa_si_comments = self.build_nyaa_si_output()

        return Context(
            neocities_stats=neocities_stats,
            dedibox_torrent_stats=dedibox_torrent_stats,
            guestbook_comments=guestbook_comments,
            nyaa_si_torrents=nyaa_si_torrents,
            nyaa_si_comments=nyaa_si_comments,
            anidex_torrents=anidex_torrents,
        )

    def build_dedibox_output(self) -> T.Tuple[
            T.List[dedibox.GuestbookComment],
            dedibox.TorrentStats
    ]:
        api = dedibox.Api()
        print('Logging into dedibox…', file=sys.stderr)
        api.login(self.args.dedibox_user, self.args.dedibox_pass)
        print('Getting guest book comment list…', file=sys.stderr)
        guestbook_comments = list(api.list_guestbook_comments())
        print('Getting transmission stats…', file=sys.stderr)
        torrent_stats = api.get_torrent_stats()
        return guestbook_comments, torrent_stats

    def build_neocities_output(self) -> T.List[neocities.TrafficStat]:
        api = neocities.Api()
        print('Logging into neocities…', file=sys.stderr)
        api.login(self.args.neocities_user, self.args.neocities_pass)
        print('Grabbing website traffic stats…', file=sys.stderr)
        return list(api.get_traffic_stats())

    def build_nyaa_si_output(self) -> T.Tuple[
            T.List[nyaa_si.Torrent],
            T.List[nyaa_si.TorrentComment]
    ]:
        api = nyaa_si.Api()
        print(f'Logging into nyaa.si…', file=sys.stderr)
        api.login(self.args.nyaasi_user, self.args.nyaasi_pass)

        print(f'Getting nyaa.si torrent list…', file=sys.stderr)
        torrents = list(api.list_user_torrents(self.args.nyaasi_user))
        comments: T.List[nyaa_si.TorrentComment] = []

        for torrent in torrents:
            if self.cached_context:
                cached_comments = [
                    comment
                    for comment in self.cached_context.nyaa_si_comments
                    if comment.torrent_id == torrent.torrent_id
                ]
            else:
                cached_comments = []

            if len(cached_comments) == torrent.comment_count:
                comments += cached_comments
            else:
                print(
                    f'Getting nyaa.si comments for "{torrent.name}"…',
                    file=sys.stderr
                )
                comments += list(api.list_torrent_comments(torrent.torrent_id))

        return torrents, comments

    def build_anidex_output(self) -> T.List[anidex.Torrent]:
        api = anidex.Api()
        print(f'Logging into anidex.info…', file=sys.stderr)
        api.login(self.args.anidex_user, self.args.anidex_pass)

        print(f'Getting anidex.info torrent list…', file=sys.stderr)
        return list(api.list_group_torrents(self.args.anidex_group))


@dataclass
class Torrent:
    source: str
    torrent_id: int
    torrent_link: str
    name: str
    size: int
    upload_date: datetime.datetime
    seeder_count: int
    leecher_count: int
    download_count: int
    comment_count: int
    visible: bool


@dataclass
class Comment:
    source: str
    comment_date: datetime.datetime
    author_name: str
    author_avatar_url: T.Optional[str]
    text: str
    torrent: T.Optional[Torrent]


@dataclass
class TrafficStat:
    day: datetime.date
    hits: int
    views: int
    hits_avg: int
    views_avg: int


class ReportContext:
    def __init__(self, context: Context) -> None:
        self.date = datetime.datetime.now()
        self.dedibox_torrent_stats = context.dedibox_torrent_stats

        self.traffic_stats: T.List[TrafficStat] = []
        try:
            import scipy.signal
            weights = {
                key - 21: value
                for key, value in enumerate(
                    scipy.signal.gaussian(M=21 * 2 + 1, std=7)
                )
            }
        except ImportError:
            weights = {
                -21: 0.011108, -20: 0.016879, -19: 0.025130,
                -18: 0.036658, -17: 0.052393, -16: 0.073369,
                -15: 0.100668, -14: 0.135335, -13: 0.178263,
                -12: 0.230066, -11: 0.290923, -10: 0.360447,
                -9: 0.437564, -8: 0.520450, -7: 0.606530,
                -6: 0.692569, -5: 0.774837, -4: 0.849365,
                -3: 0.912254, -2: 0.960005, -1: 0.989847,
                0: 1.0,
                1: 0.989847, 2: 0.960005, 3: 0.912254,
                4: 0.849365, 5: 0.774837, 6: 0.692569,
                7: 0.606530, 8: 0.520450, 9: 0.437564,
                10: 0.360447, 11: 0.290923, 12: 0.230066,
                13: 0.178263, 14: 0.135335, 15: 0.100668,
                16: 0.073369, 17: 0.052393, 18: 0.036658,
                19: 0.025130, 20: 0.016879, 21: 0.011108,
            }

        for i, item in enumerate(context.neocities_stats):
            total_weight = 0
            hits_avg = 0
            views_avg = 0
            for delta, weight in weights.items():
                try:
                    other_item = context.neocities_stats[i + delta]
                except LookupError:
                    continue
                hits_avg += other_item.hits * weight
                views_avg += other_item.views * weight
                total_weight += weight

            self.traffic_stats.append(TrafficStat(
                day=item.day,
                hits=item.hits,
                views=item.views,
                hits_avg=hits_avg / max(1, total_weight),
                views_avg=views_avg / max(1, total_weight),
            ))

        self.torrents: T.List[Torrent] = []
        for torrent in context.nyaa_si_torrents:
            self.torrents.append(self._torrent_from_nyaa_si(torrent))

        for torrent in context.anidex_torrents:
            self.torrents.append(self._torrent_from_anidex(torrent))

        self.comments: T.List[Comment] = []
        for comment in context.nyaa_si_comments:
            self.comments.append(
                self._comment_from_nyaa_si(comment, self.torrents)
            )

        for comment in context.guestbook_comments:
            self.comments.append(self._comment_from_guestbook(comment))

    @staticmethod
    def _torrent_from_nyaa_si(torrent: nyaa_si.Torrent) -> Torrent:
        return Torrent(
            source='nyaa.si',
            torrent_id=torrent.torrent_id,
            torrent_link=f'https://nyaa.si/view/{torrent.torrent_id}',
            name=torrent.name,
            size=torrent.size,
            upload_date=torrent.upload_date,
            seeder_count=torrent.seeder_count,
            leecher_count=torrent.leecher_count,
            download_count=torrent.download_count,
            comment_count=torrent.comment_count,
            visible=torrent.visible,
        )

    @staticmethod
    def _torrent_from_anidex(torrent: anidex.Torrent) -> Torrent:
        return Torrent(
            source='anidex.info',
            torrent_id=torrent.torrent_id,
            torrent_link=f'https://anidex.info/torrent/{torrent.torrent_id}',
            name=torrent.name,
            size=torrent.size,
            upload_date=torrent.upload_date,
            seeder_count=torrent.seeder_count,
            leecher_count=torrent.leecher_count,
            download_count=torrent.download_count,
            comment_count=torrent.comment_count,
            visible=torrent.visible,
        )

    @staticmethod
    def _comment_from_nyaa_si(
            comment: nyaa_si.TorrentComment,
            torrents: T.List[Torrent],
    ) -> Comment:
        return Comment(
            source='nyaa.si',
            comment_date=comment.comment_date,
            author_name=comment.author_name,
            author_avatar_url=comment.author_avatar_url,
            text=comment.text,
            torrent=next(
                torrent
                for torrent in torrents
                if torrent.torrent_id == comment.torrent_id
                and torrent.source == 'nyaa.si'
            )
        )

    @staticmethod
    def _comment_from_guestbook(comment: dedibox.GuestbookComment) -> Comment:
        return Comment(
            source='guestbook',
            comment_date=comment.comment_date,
            author_name=comment.author_name,
            author_avatar_url=comment.author_avatar_url,
            text=comment.text,
            torrent=None,
        )


def write_report(
        args: configargparse.Namespace,
        report_context: ReportContext,
) -> None:
    print(f'Writing output to {args.output}…', file=sys.stderr)
    md = markdown.Markdown(extensions=['meta'])
    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(str(ROOT_PATH / 'data'))
    )
    env.filters['markdown'] = lambda text: jinja2.Markup(md.convert(text))
    env.filters['tojson'] = lambda obj: json.dumps(obj, default=json_default)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(
        env.get_template('report.html').render(**report_context.__dict__)
    )


def parse_args() -> configargparse.Namespace:
    parser = configargparse.ArgumentParser(
        formatter_class=configargparse.RawTextHelpFormatter,
        default_config_files=[Path(xdg.XDG_CONFIG_HOME) / 'oc-tools.yml']
    )

    parser.add_argument('--neocities-user', required=True)
    parser.add_argument('--neocities-pass', required=True)
    parser.add_argument('--dedibox-user', required=True)
    parser.add_argument('--dedibox-pass', required=True)
    parser.add_argument('--anidex-user', required=True)
    parser.add_argument('--anidex-pass', required=True)
    parser.add_argument('--anidex-group', type=int, required=True)
    parser.add_argument('--nyaasi-user', required=True)
    parser.add_argument('--nyaasi-pass', required=True)
    parser.add_argument('-d', '--dev', action='store_true')
    parser.add_argument(
        '-o',
        '--output',
        default=Path('stats.html'),
        type=Path,
        required=False
    )

    return parser.parse_known_args()[0]


def main() -> None:
    args = parse_args()

    if CACHE_PATH.exists():
        prev_context = pickle.loads(CACHE_PATH.read_bytes())
    else:
        prev_context = None

    if args.dev and prev_context:
        context = prev_context
    else:
        context = ContextBuilder(args, prev_context).build()

    CACHE_PATH.write_bytes(pickle.dumps(context))

    report_context = ReportContext(context)
    write_report(args, report_context)


if __name__ == '__main__':
    main()
